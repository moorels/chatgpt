{
  "version": 3,
  "sources": ["../../src/lib/auth.ts"],
  "sourcesContent": ["import type { Decoded } from '@redwoodjs/api'\r\nimport { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\r\n\r\nimport { db } from './db'\r\n\r\n/**\r\n * The session object sent in as the first argument to getCurrentUser() will\r\n * have a single key `id` containing the unique ID of the logged in user\r\n * (whatever field you set as `authFields.id` in your auth function config).\r\n * You'll need to update the call to `db` below if you use a different model\r\n * name or unique field name, for example:\r\n *\r\n *   return await db.profile.findUnique({ where: { email: session.id } })\r\n *                   ───┬───                       ──┬──\r\n *      model accessor ─┘      unique id field name ─┘\r\n *\r\n * !! BEWARE !! Anything returned from this function will be available to the\r\n * client--it becomes the content of `currentUser` on the web side (as well as\r\n * `context.currentUser` on the api side). You should carefully add additional\r\n * fields to the `select` object below once you've decided they are safe to be\r\n * seen if someone were to open the Web Inspector in their browser.\r\n */\r\nexport const getCurrentUser = async (session: Decoded) => {\r\n  if (!session || typeof session.id !== 'number') {\r\n    throw new Error('Invalid session')\r\n  }\r\n\r\n  return await db.user.findUnique({\r\n    where: { id: session.id },\r\n    select: { id: true },\r\n  })\r\n}\r\n\r\n/**\r\n * The user is authenticated if there is a currentUser in the context\r\n *\r\n * @returns {boolean} - If the currentUser is authenticated\r\n */\r\nexport const isAuthenticated = (): boolean => {\r\n  return !!context.currentUser\r\n}\r\n\r\n/**\r\n * When checking role membership, roles can be a single value, a list, or none.\r\n * You can use Prisma enums too (if you're using them for roles), just import your enum type from `@prisma/client`\r\n */\r\ntype AllowedRoles = string | string[] | undefined\r\n\r\n/**\r\n * Checks if the currentUser is authenticated (and assigned one of the given roles)\r\n *\r\n * @param roles: {@link AllowedRoles} - Checks if the currentUser is assigned one of these roles\r\n *\r\n * @returns {boolean} - Returns true if the currentUser is logged in and assigned one of the given roles,\r\n * or when no roles are provided to check against. Otherwise returns false.\r\n */\r\nexport const hasRole = (roles: AllowedRoles): boolean => {\r\n  if (!isAuthenticated()) {\r\n    return false\r\n  }\r\n\r\n  const currentUserRoles = context.currentUser?.roles\r\n\r\n  if (typeof roles === 'string') {\r\n    if (typeof currentUserRoles === 'string') {\r\n      // roles to check is a string, currentUser.roles is a string\r\n      return currentUserRoles === roles\r\n    } else if (Array.isArray(currentUserRoles)) {\r\n      // roles to check is a string, currentUser.roles is an array\r\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(roles)) {\r\n    if (Array.isArray(currentUserRoles)) {\r\n      // roles to check is an array, currentUser.roles is an array\r\n      return currentUserRoles?.some((allowedRole) =>\r\n        roles.includes(allowedRole)\r\n      )\r\n    } else if (typeof currentUserRoles === 'string') {\r\n      // roles to check is an array, currentUser.roles is a string\r\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\r\n    }\r\n  }\r\n\r\n  // roles not found\r\n  return false\r\n}\r\n\r\n/**\r\n * Use requireAuth in your services to check that a user is logged in,\r\n * whether or not they are assigned a role, and optionally raise an\r\n * error if they're not.\r\n *\r\n * @param roles: {@link AllowedRoles} - When checking role membership, these roles grant access.\r\n *\r\n * @returns - If the currentUser is authenticated (and assigned one of the given roles)\r\n *\r\n * @throws {@link AuthenticationError} - If the currentUser is not authenticated\r\n * @throws {@link ForbiddenError} If the currentUser is not allowed due to role permissions\r\n *\r\n * @see https://github.com/redwoodjs/redwood/tree/main/packages/auth for examples\r\n */\r\nexport const requireAuth = ({ roles }: { roles?: AllowedRoles } = {}) => {\r\n  if (!isAuthenticated()) {\r\n    throw new AuthenticationError(\"You don't have permission to do that.\")\r\n  }\r\n\r\n  if (roles && !hasRole(roles)) {\r\n    throw new ForbiddenError(\"You don't have access to do that.\")\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,4BAAoD;AAEpD,gBAAmB;AAmBZ,MAAMA,iBAAiB,OAAOC,YAAqB;AACxD,MAAI,CAACA,WAAW,OAAOA,QAAQC,OAAO,UAAU;AAC9C,UAAM,IAAIC,MAAM,iBAAiB;EACnC;AAEA,SAAO,MAAMC,aAAGC,KAAKC,WAAW;IAC9BC,OAAO;MAAEL,IAAID,QAAQC;IAAG;IACxBM,QAAQ;MAAEN,IAAI;IAAK;EACrB,CAAC;AACH;AAOO,MAAMO,kBAAkBA,MAAe;AAC5C,SAAO,CAAC,CAACC,8BAAQC;AACnB;AAgBO,MAAMC,UAAWC,WAAiC;AACvD,MAAI,CAACJ,gBAAgB,GAAG;AACtB,WAAO;EACT;AAEA,QAAMK,mBAAmBJ,8BAAQC,aAAaE;AAE9C,MAAI,OAAOA,UAAU,UAAU;AAC7B,QAAI,OAAOC,qBAAqB,UAAU;AAExC,aAAOA,qBAAqBD;IAC9B,eAAWE,gBAAAA,SAAcD,gBAAgB,GAAG;AAE1C,aAAOA,kBAAkBE,KAAMC,iBAAgBJ,UAAUI,WAAW;IACtE;EACF;AAEA,UAAIF,gBAAAA,SAAcF,KAAK,GAAG;AACxB,YAAIE,gBAAAA,SAAcD,gBAAgB,GAAG;AAEnC,aAAOA,kBAAkBE,KAAMC,qBAC7BC,gBAAAA,SAAAL,KAAK,EAAAM,KAALN,OAAeI,WAAW,CAC5B;IACF,WAAW,OAAOH,qBAAqB,UAAU;AAE/C,iBAAOM,YAAAA,SAAAP,KAAK,EAAAM,KAALN,OAAYI,iBAAgBH,qBAAqBG,WAAW;IACrE;EACF;AAGA,SAAO;AACT;AAgBO,MAAMI,cAAcA,CAAC;EAAER;AAAgC,IAAI,CAAC,MAAM;AACvE,MAAI,CAACJ,gBAAgB,GAAG;AACtB,UAAM,IAAIa,0CAAoB,uCAAuC;EACvE;AAEA,MAAIT,SAAS,CAACD,QAAQC,KAAK,GAAG;AAC5B,UAAM,IAAIU,qCAAe,mCAAmC;EAC9D;AACF;",
  "names": ["getCurrentUser", "session", "id", "Error", "db", "user", "findUnique", "where", "select", "isAuthenticated", "context", "currentUser", "hasRole", "roles", "currentUserRoles", "_Array$isArray", "some", "allowedRole", "_includesInstanceProperty", "call", "_someInstanceProperty", "requireAuth", "AuthenticationError", "ForbiddenError"]
}
