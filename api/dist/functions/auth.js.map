{
  "version": 3,
  "sources": ["../../src/functions/auth.ts"],
  "sourcesContent": ["import type { APIGatewayProxyEvent, Context } from 'aws-lambda'\r\n\r\nimport { DbAuthHandler, DbAuthHandlerOptions } from '@redwoodjs/auth-dbauth-api'\r\n\r\nimport { db } from 'src/lib/db'\r\n\r\nexport const handler = async (\r\n  event: APIGatewayProxyEvent,\r\n  context: Context\r\n) => {\r\n  const forgotPasswordOptions: DbAuthHandlerOptions['forgotPassword'] = {\r\n    // handler() is invoked after verifying that a user was found with the given\r\n    // username. This is where you can send the user an email with a link to\r\n    // reset their password. With the default dbAuth routes and field names, the\r\n    // URL to reset the password will be:\r\n    //\r\n    // https://example.com/reset-password?resetToken=${user.resetToken}\r\n    //\r\n    // Whatever is returned from this function will be returned from\r\n    // the `forgotPassword()` function that is destructured from `useAuth()`\r\n    // You could use this return value to, for example, show the email\r\n    // address in a toast message so the user will know it worked and where\r\n    // to look for the email.\r\n    handler: (user) => {\r\n      return user\r\n    },\r\n\r\n    // How long the resetToken is valid for, in seconds (default is 24 hours)\r\n    expires: 60 * 60 * 24,\r\n\r\n    errors: {\r\n      // for security reasons you may want to be vague here rather than expose\r\n      // the fact that the email address wasn't found (prevents fishing for\r\n      // valid email addresses)\r\n      usernameNotFound: 'Username not found',\r\n      // if the user somehow gets around client validation\r\n      usernameRequired: 'Username is required',\r\n    },\r\n  }\r\n\r\n  const loginOptions: DbAuthHandlerOptions['login'] = {\r\n    // handler() is called after finding the user that matches the\r\n    // username/password provided at login, but before actually considering them\r\n    // logged in. The `user` argument will be the user in the database that\r\n    // matched the username/password.\r\n    //\r\n    // If you want to allow this user to log in simply return the user.\r\n    //\r\n    // If you want to prevent someone logging in for another reason (maybe they\r\n    // didn't validate their email yet), throw an error and it will be returned\r\n    // by the `logIn()` function from `useAuth()` in the form of:\r\n    // `{ message: 'Error message' }`\r\n    handler: (user) => {\r\n      return user\r\n    },\r\n\r\n    errors: {\r\n      usernameOrPasswordMissing: 'Both username and password are required',\r\n      usernameNotFound: 'Username ${username} not found',\r\n      // For security reasons you may want to make this the same as the\r\n      // usernameNotFound error so that a malicious user can't use the error\r\n      // to narrow down if it's the username or password that's incorrect\r\n      incorrectPassword: 'Incorrect password for ${username}',\r\n    },\r\n\r\n    // How long a user will remain logged in, in seconds\r\n    expires: 60 * 60 * 24 * 365 * 10,\r\n  }\r\n\r\n  const resetPasswordOptions: DbAuthHandlerOptions['resetPassword'] = {\r\n    // handler() is invoked after the password has been successfully updated in\r\n    // the database. Returning anything truthy will automatically log the user\r\n    // in. Return `false` otherwise, and in the Reset Password page redirect the\r\n    // user to the login page.\r\n    handler: (_user) => {\r\n      return true\r\n    },\r\n\r\n    // If `false` then the new password MUST be different from the current one\r\n    allowReusedPassword: true,\r\n\r\n    errors: {\r\n      // the resetToken is valid, but expired\r\n      resetTokenExpired: 'resetToken is expired',\r\n      // no user was found with the given resetToken\r\n      resetTokenInvalid: 'resetToken is invalid',\r\n      // the resetToken was not present in the URL\r\n      resetTokenRequired: 'resetToken is required',\r\n      // new password is the same as the old password (apparently they did not forget it)\r\n      reusedPassword: 'Must choose a new password',\r\n    },\r\n  }\r\n\r\n  const signupOptions: DbAuthHandlerOptions['signup'] = {\r\n    // Whatever you want to happen to your data on new user signup. Redwood will\r\n    // check for duplicate usernames before calling this handler. At a minimum\r\n    // you need to save the `username`, `hashedPassword` and `salt` to your\r\n    // user table. `userAttributes` contains any additional object members that\r\n    // were included in the object given to the `signUp()` function you got\r\n    // from `useAuth()`.\r\n    //\r\n    // If you want the user to be immediately logged in, return the user that\r\n    // was created.\r\n    //\r\n    // If this handler throws an error, it will be returned by the `signUp()`\r\n    // function in the form of: `{ error: 'Error message' }`.\r\n    //\r\n    // If this returns anything else, it will be returned by the\r\n    // `signUp()` function in the form of: `{ message: 'String here' }`.\r\n    handler: ({ username, hashedPassword, salt, userAttributes }) => {\r\n      return db.user.create({\r\n        data: {\r\n          email: username,\r\n          hashedPassword: hashedPassword,\r\n          salt: salt,\r\n          // name: userAttributes.name\r\n        },\r\n      })\r\n    },\r\n\r\n    // Include any format checks for password here. Return `true` if the\r\n    // password is valid, otherwise throw a `PasswordValidationError`.\r\n    // Import the error along with `DbAuthHandler` from `@redwoodjs/api` above.\r\n    passwordValidation: (_password) => {\r\n      return true\r\n    },\r\n\r\n    errors: {\r\n      // `field` will be either \"username\" or \"password\"\r\n      fieldMissing: '${field} is required',\r\n      usernameTaken: 'Username `${username}` already in use',\r\n    },\r\n  }\r\n\r\n  const authHandler = new DbAuthHandler(event, context, {\r\n    // Provide prisma db client\r\n    db: db,\r\n\r\n    // The name of the property you'd call on `db` to access your user table.\r\n    // i.e. if your Prisma model is named `User` this value would be `user`, as in `db.user`\r\n    authModelAccessor: 'user',\r\n\r\n    // A map of what dbAuth calls a field to what your database calls it.\r\n    // `id` is whatever column you use to uniquely identify a user (probably\r\n    // something like `id` or `userId` or even `email`)\r\n    authFields: {\r\n      id: 'id',\r\n      username: 'email',\r\n      hashedPassword: 'hashedPassword',\r\n      salt: 'salt',\r\n      resetToken: 'resetToken',\r\n      resetTokenExpiresAt: 'resetTokenExpiresAt',\r\n    },\r\n\r\n    // Specifies attributes on the cookie that dbAuth sets in order to remember\r\n    // who is logged in. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies\r\n    cookie: {\r\n      HttpOnly: true,\r\n      Path: '/',\r\n      SameSite: 'Strict',\r\n      Secure: process.env.NODE_ENV !== 'development',\r\n\r\n      // If you need to allow other domains (besides the api side) access to\r\n      // the dbAuth session cookie:\r\n      // Domain: 'example.com',\r\n    },\r\n\r\n    forgotPassword: forgotPasswordOptions,\r\n    login: loginOptions,\r\n    resetPassword: resetPasswordOptions,\r\n    signup: signupOptions,\r\n  })\r\n\r\n  return await authHandler.invoke()\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAEA;;;;;6BAAoD;AAEpD,gBAAW;AAEJ,MAAMA,UAAU,OACrBC,OACAC,YACG;AACH,QAAMC,wBAAgE;;;;;;;;;;;;;IAapEH,SAAUI,UAAS;AACjB,aAAOA;IACT;;IAGAC,SAAS,KAAK,KAAK;IAEnBC,QAAQ;;;;MAINC,kBAAkB;;MAElBC,kBAAkB;IACpB;EACF;AAEA,QAAMC,eAA8C;;;;;;;;;;;;IAYlDT,SAAUI,UAAS;AACjB,aAAOA;IACT;IAEAE,QAAQ;MACNI,2BAA2B;MAC3BH,kBAAkB;;;;MAIlBI,mBAAmB;IACrB;;IAGAN,SAAS,KAAK,KAAK,KAAK,MAAM;EAChC;AAEA,QAAMO,uBAA8D;;;;;IAKlEZ,SAAUa,WAAU;AAClB,aAAO;IACT;;IAGAC,qBAAqB;IAErBR,QAAQ;;MAENS,mBAAmB;;MAEnBC,mBAAmB;;MAEnBC,oBAAoB;;MAEpBC,gBAAgB;IAClB;EACF;AAEA,QAAMC,gBAAgD;;;;;;;;;;;;;;;;IAgBpDnB,SAASA,CAAC;MAAEoB;MAAUC;MAAgBC;MAAMC;IAAe,MAAM;AAC/D,aAAOC,aAAGpB,KAAKqB,OAAO;QACpBC,MAAM;UACJC,OAAOP;UACPC;UACAC;;QAEF;MACF,CAAC;IACH;;;;IAKAM,oBAAqBC,eAAc;AACjC,aAAO;IACT;IAEAvB,QAAQ;;MAENwB,cAAc;MACdC,eAAe;IACjB;EACF;AAEA,QAAMC,cAAc,IAAIC,qCAAchC,OAAOC,SAAS;;IAEpDsB,IAAIA;;;IAIJU,mBAAmB;;;;IAKnBC,YAAY;MACVC,IAAI;MACJhB,UAAU;MACVC,gBAAgB;MAChBC,MAAM;MACNe,YAAY;MACZC,qBAAqB;IACvB;;;IAIAC,QAAQ;MACNC,UAAU;MACVC,MAAM;MACNC,UAAU;MACVC,QAAQC,QAAQC,IAAIC,aAAa;;;;IAKnC;IAEAC,gBAAgB5C;IAChB6C,OAAOvC;IACPwC,eAAerC;IACfsC,QAAQ/B;EACV,CAAC;AAED,SAAO,MAAMa,YAAYmB,OAAO;AAClC;",
  "names": ["handler", "event", "context", "forgotPasswordOptions", "user", "expires", "errors", "usernameNotFound", "usernameRequired", "loginOptions", "usernameOrPasswordMissing", "incorrectPassword", "resetPasswordOptions", "_user", "allowReusedPassword", "resetTokenExpired", "resetTokenInvalid", "resetTokenRequired", "reusedPassword", "signupOptions", "username", "hashedPassword", "salt", "userAttributes", "db", "create", "data", "email", "passwordValidation", "_password", "fieldMissing", "usernameTaken", "authHandler", "DbAuthHandler", "authModelAccessor", "authFields", "id", "resetToken", "resetTokenExpiresAt", "cookie", "HttpOnly", "Path", "SameSite", "Secure", "process", "env", "NODE_ENV", "forgotPassword", "login", "resetPassword", "signup", "invoke"]
}
